
# https://www.acmicpc.net/problem/1011

# 어려운문제임 구글에 검색시 잘못된 풀이 많음!
# 문제요약
# 이동이 k-1 k k+1로만 이동 가능
# 바로 직전거리는 1이다.


# 입력
# 입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x < y < 231)

# 출력
# 각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.

# 예제 입력 1 
# 3
# 0 3
# 1 5
# 45 50
# 예제 출력 1 
# 3
# 3
# 4

# 문제풀이

# 생각하기 어렵다. 노트 활용 및 규칙을 찾아야 한다

# 거리 / 이동 / 횟수 / 횟수 증가 시점 / 수식
# 1	/ 1 / 1	 	 
# 2	/ 11 / 2	 	 
# 3	/ 111 /3

# 3이하의 거리는 그대로 출력되는 것을 알 수 있다!

# 4 / 121 / 3 / 2의 제곱 / 2*2-1   //제곱의 숫자 일 때 = 2*제곱근 - 1인것을 알 수 있다.

# 5 / 1211 / 4	 	 
# 6 / 1221 / 4	/ 2의 제곱 + 2 / 2*2  //제곱의 숫자 + 제곱근 일때 = 2*제곱근 인것을 알 수 있다.
# 7 / 12211 / 5	 	 
# 8 / 12221 / 5	 	 
# 9 / 12321 / 5	 / 3의 제곱 / 2*3-1  //제곱의 숫자 일떄 = 2*제곱근 -1 확인!
# 10 / 123211 / 6	 	 
# 11 / 123221 / 6	 	 
# 12 / 123321 / 6 / 3의 제곱 + 3 / 2*3 // 제곱의 숫자 + 제곱근일떄 = 

#1. math import!
import math


#2. 받을 갯수를 받고 받을 x,y를 받아서 차이를 리스트에 넣어준다!
N = int(input())
dist = []

for i in range(N) :
    x,y = map(int, input().split())
    dist.append(y-x)

#3. 리스트 dist를 반복문 시켜서 출력
for dis in dist : 
    num = math.floor(math.sqrt(dis))
    
    if dis <=3 :  #3이하에서는 똑같으므로 바로 출력해줌
        print(dis)
    elif dis == num **2: # 제곱의 숫자일때 2*num -1!
        print((2*num)-1) 
    elif (num**2) < dis <= (num**2 + num) :  #제곱의 숫자보다는 크고 제곱근 + 제곱근까지!
        print(2*num)
    else :  #제곱근 + 제곱근 이후 새 재곱근의 숫자까지!
        print(2*num+1)