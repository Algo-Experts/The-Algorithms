# https://www.acmicpc.net/problem/2667

# 문제풀이
# 1은 집 0은 비어있는 곳이다.
# 연결된 곳은 단지이다
# 총 단지수, 단지마다의 갯수를 출력

# 입력
# 첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.

# 출력
# 첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.

# 예제 입력 1 
# 7
# 0110100
# 0110101
# 1110101
# 0000111
# 0100000
# 0111110
# 0111000
# 예제 출력 1 
# 3
# 7
# 8
# 9

# 문제풀이
# 이전문제 참고하면서 풀어봄
# 이제야 감이 옴.
# 결과도 확인해봤는데 구글링했을 때 보다 더 코드가 간략함

N = int(input())
maps = [list(input()) for _ in range(N)]
r = [] # 결과값을 저장함

#상하좌우 앞으로 계속 쓸거같음
dx = [-1, 1, 0, 0] 
dy = [0, 0, -1, 1]

def bfs(a,b): # 전체 위치에서 검색해야 하므로 함수가 필요함
    n = 1 # 갯수가 필요함
    maps[a][b] = 1 # 방문 표시로 int로 변경
    q=[(a,b)] # 값을 넣어줌

    while q : 
        x1,y1=q.pop(0) #계속 하나씩 빼냄
        for i in range(4) :
            x = x1 + dx[i]
            y = y1 + dy[i]

            if 0 <= x < N and 0<= y < N and maps[x][y] == "1":
                q.append((x,y))
                # 안간곳으면 int로 변경 및 갯수+1
                maps[x][y] = 1
                n +=1 # 
    return(n)

for i in range(N) :
    for j in range(N) :
        if maps[i][j] == "1" : # 해당값이 "1"이면
            r.append(bfs(i,j)) # 결과값에 더해줌

print(len(r),*sorted(r), sep='\n') # 갯수 / *배열을 풀어주는것 / 정렬 / 값마다 엔터기준으로 나눠줌
        

    




        

    


