# https://www.acmicpc.net/problem/16236

# 문제요약
# 아기상어는 크기가 2인데 1초마다 상하좌우로 움직임
# 자기보다 큰 물고기가 있으면 지나갈 수 없다
# 자기보다 작으면 먹을 수 있고 같으면 지나만 갈 수 있다
# 우선 위쪽부터 가고 가장 많으면 왼쪽부터 먹는다
# 크기가 2인 아기상어는 2마리를 먹어야 3이된다.
# 공간이 주어졌을 경우 몇 초동안 물고기를 잡아 먹을 수 있는지 구함 

# 입력
# 첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.

# 둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.

# 0: 빈 칸
# 1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
# 9: 아기 상어의 위치
# 아기 상어는 공간에 한 마리 있다.

# 출력
# 첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.

# 예제 입력 1 
# 3
# 0 0 0
# 0 0 0
# 0 9 0
# 예제 출력 1 
# 0
# 예제 입력 2 
# 3
# 0 0 1
# 0 0 0
# 0 9 0
# 예제 출력 2 
# 3
# 예제 입력 3 
# 4
# 4 3 2 1
# 0 0 0 0
# 0 0 9 0
# 1 2 3 4
# 예제 출력 3 
# 14
# 예제 입력 4 
# 6
# 5 4 3 2 3 4
# 4 3 2 3 4 5
# 3 2 9 5 6 6
# 2 1 2 3 4 5
# 3 2 1 6 5 4
# 6 6 6 6 6 6
# 예제 출력 4 
# 60
# 예제 입력 5 
# 6
# 6 0 6 0 6 1
# 0 0 0 0 0 2
# 2 3 4 5 6 6
# 0 0 0 0 0 2
# 0 2 0 0 0 0
# 3 9 3 0 0 1
# 예제 출력 5 
# 48
# 예제 입력 6 
# 6
# 1 1 1 1 1 1
# 2 2 6 2 2 3
# 2 2 5 2 2 3
# 2 2 2 4 6 3
# 0 0 0 0 0 6
# 0 0 0 0 0 9
# 예제 출력 6 
# 39

# 문제풀이
# 생각보다 조건이 많은 문제임
# 초를 구하기 때문에 BFS를 사용함
# 이건 조건이 많아서 생각을 많이해야함 어려움 ㅠ

import sys
from collections import deque
N = int(sys.stdin.readline())
# 이동
dx = [1, -1, 0, 0]
dy = [0, 0, -1, 1]
g = [] # 그래프 = 맵
s = deque() # 아기상어의 시작지점
exp = 0 # 경험치 - 조건중에 2일경우엔 2개를 먹고 3일경우엔 3마리를 먹어야함
cnt = 0 # 초

for i in range(N) :
    m=list(map(int, sys.stdin.readline().split()))
    g.append(m)
    for j in range(N) :
        if m[j] == 9 : # 처음 아기상어의 위치
            g[i][j] = 2 # 조건중에 2부터 시작하므로 2로 바꿔줌
            s.append((i,j)) # 시작지점에 넣어준다

def bfs(a,b) :
    # 방문기록은 새로 시작할경우 초기화 해야하므로 여기로 둬야함
    v = [[0]*N for _ in range(N)] 
    v[a][b] = 1
    dist=[[0]*N for _ in range(N)] # 거리저장
    eat = [] # 출력값 x,y,거리저장
    q=deque()
    q.append((a,b))

    while q:
        x1,y1 = q.popleft()
        for i in range(4) :
            x = x1 + dx[i]
            y = y1 + dy[i]
            if 0 <= x < N and 0 <= y < N and v[x][y] == 0 :
                if g[x][y] <= g[a][b] : # 상어의 크기보다 작거나 같은경우 이동
                    v[x][y] = 1 # 방문
                    dist[x][y] = dist[x1][y1] + 1 # 거리 +1 해줌
                    q.append((x,y)) 
                if g[x][y] < g[a][b] and g[x][y] != 0: #방문 + 상어보다 작으면 
                    eat.append([x, y, dist[x][y]]) # 먹이 리스트에 추가
    
    if not eat :
        return -1, -1, -1
    
    eat.sort(key=lambda x: (x[2], x[0], x[1])) # 거리,y,x 기준으로 정렬 람다사용 포인트!
    return eat[0][0], eat[0][1], eat[0][2] # 첫번째꺼만 먹는다 나머지는 사라짐

while True : # 없을 때까지 무한반복
    i,j = s.popleft() # 해당 위치 빼내줌
    ex, ey, dist = bfs(i,j) # 메소드 실행해서 다음 x,y,dist(거리=초)를 가져옴
    if ex == -1: break # 먹을게 없을경우 -1을 가져오는데 그때는 스탑!
    g[ex][ey] = g[i][j] # 상어의 위치를 새로운 좌표로 옮김
    g[i][j] = 0 # 원래 있던 상어의 자리는 빈칸으로 바꿈
    s.append((ex,ey)) # 새 좌표를 추가함
    exp+=1 # 먹을 때 마다 경험치 +1
    if exp ==g[ex][ey] : # 경험치가 상어의 크기와 같을경우
        exp = 0 # 경험치 초기화
        g[ex][ey] += 1 # 상어크기 +1 증가
    cnt += dist # 거리만큼 초 추가함

print(cnt)


