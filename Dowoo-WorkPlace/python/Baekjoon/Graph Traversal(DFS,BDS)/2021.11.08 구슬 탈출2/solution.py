# https://www.acmicpc.net/problem/13460

# 문제요약
# 빨간 구술과 파란 구슬이 있다. 
# 구멍이 있는데 구멍에서 빨간 구슬만 빼내야 하고 파란구슬이 들어가면 안된다.
# 상하좌우로 기울기 가능
# 공은 전체 동시에 움직임
# 최소 몇번만에 빨간 구슬을 빼낼 수 있는지 구하라

# 입력
# 첫 번째 줄에는 보드의 세로, 가로 크기를 의미하는 두 정수 N, M (3 ≤ N, M ≤ 10)이 주어진다. 다음 N개의 줄에 보드의 모양을 나타내는 길이 M의 문자열이 주어진다. 이 문자열은 '.', '#', 'O', 'R', 'B' 로 이루어져 있다. '.'은 빈 칸을 의미하고, '#'은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, 'O'는 구멍의 위치를 의미한다. 'R'은 빨간 구슬의 위치, 'B'는 파란 구슬의 위치이다.

# 입력되는 모든 보드의 가장자리에는 모두 '#'이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다.

# 출력
# 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력한다. 만약, 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1을 출력한다.

# 예제 입력 1 
# 5 5
# #####
# #..B#
# #.#.#
# #RO.#
# #####
# 예제 출력 1 
# 1
# 예제 입력 2 
# 7 7
# #######
# #...RB#
# #.#####
# #.....#
# #####.#
# #O....#
# #######
# 예제 출력 2 
# 5
# 예제 입력 3 
# 7 7
# #######
# #..R#B#
# #.#####
# #.....#
# #####.#
# #O....#
# #######
# 예제 출력 3 
# 5
# 예제 입력 4 
# 10 10
# ##########
# #R#...##B#
# #...#.##.#
# #####.##.#
# #......#.#
# #.######.#
# #.#....#.#
# #.#.#.#..#
# #...#.O#.#
# ##########
# 예제 출력 4 
# -1
# 예제 입력 5 
# 3 7
# #######
# #R.O.B#
# #######
# 예제 출력 5 
# 1
# 예제 입력 6 
# 10 10
# ##########
# #R#...##B#
# #...#.##.#
# #####.##.#
# #......#.#
# #.######.#
# #.#....#.#
# #.#.##...#
# #O..#....#
# ##########
# 예제 출력 6 
# 7
# 예제 입력 7 
# 3 10
# ##########
# #.O....RB#
# ##########
# 예제 출력 7 
# -1

# 문제풀이
# .은 빈칸, #은 장애물, 0은 구멍, R = 빨간구슬, B = 파란구슬 
# 최소이기 때문에 BFS로 구한다
# 삼성문제인데 너무 어려웠다. 복잡한 문제였음
# 좌표를 따로 처리해야하고 그것을 추가해줘야함!

from collections import deque
import sys

N,M = map(int, sys.stdin.readline().split())
g = [list(sys.stdin.readline().rstrip()) for _ in range(N)]
# 좌표를 다 포함시킴
v = [[[[0]*M for _ in range(N)] for _ in range(M)] for _ in range(N)]
dx = [-1, 1, 0, 0] 
dy = [0, 0, -1, 1]
q = deque()
for i in range(N) :
    for j in range(M) :
        if g[i][j] == "R" : # 빨간구슬 좌표저장
            ri, rj = i, j
        if g[i][j] == "B" : # 파란구슬 좌표저장
            bi,bj  = i, j
q.append((ri,rj,bi,bj,1)) # 위치정보 저장
v[ri][rj][bi][bj] = 1 # 방문표시

def move(x,y,dx,dy) :# 이동함수
    cnt = 0 # 이동칸수
    while g[x+dx][y+dy] != '#' and g[x][y] != 'O' : # 다음벽이 벽 또는 구멍이 아닐 때까지
        x += dx
        y += dy
        cnt += 1
    return x,y,cnt # 좌표에 이동칸수 저장

def bfs() :
    while q :
        ri,rj,bi,bj,c = q.popleft() # 좌표+카운트
        if c > 10 : # 10번 넘어가면 끝내고 -1출력
            break
        for i in range(4) :
            ri1,rj1,rc = move(ri,rj,dx[i],dy[i]) # 레드 좌표이동 후 값 입력
            bi1,bj1,bc = move(bi,bj,dx[i],dy[i]) # 블루 좌표이동 후 값 입력
            if g[bi1][bj1] != "O" : # 파란구슬이 떨어지지 않을 때
                if g[ri1][rj1] == "O" : # 레드가 0에 위치하면(성공시)
                    print(c) # 카운트 출력 후 끝!
                    return
                if ri1 == bi1 and rj1 == bj1: # 빨간 파란 구슬이 같은 칸에 있을겨우(불가능한 경우임)
                    if rc > bc: # 이동거리가 많으면 한칸 뒤로!
                        ri1 -= dx[i]
                        rj1 -= dy[i]
                    else:
                        bi1 -= dx[i]
                        bj1 -= dy[i]
                if not v[ri1][rj1][bi1][bj1]: #방문여부 확인 후 카운트 +1 후 다시 진행!
                    v[ri1][rj1][bi1][bj1] = 1
                    q.append([ri1, rj1, bi1, bj1, c + 1])
    print(-1) # 끝냈을 경우!

bfs()


    


