# https://www.acmicpc.net/problem/17070

# 파이프를 오른쪽, 아래로, 대각현으로 이동이 가능하다
# 가로일경우 오른쪽, 대각선 2가지
# 세로일경우 아래, 대각선 2가지
# 대각선일경우 오른쪽, 아래, 대각선 3가지다.
# 0은 빈칸 1은 벽이다 
# 끝을 오른쪽 맨 아래로 옳길 수 있는 방법의 갯수를 구하기

# 입력
# 첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.

# 출력
# 첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.

# 예제 입력 1 
# 3
# 0 0 0
# 0 0 0
# 0 0 0
# 예제 출력 1 
# 1
# 예제 입력 2 
# 4
# 0 0 0 0
# 0 0 0 0
# 0 0 0 0
# 0 0 0 0
# 예제 출력 2 
# 3
# 예제 입력 3 
# 5
# 0 0 1 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 0 0 0 0 0
# 예제 출력 3 
# 0
# 예제 입력 4 
# 6
# 0 0 0 0 0 0
# 0 1 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 0 0 0 0 0 0
# 예제 출력 4 
# 13

# 문제풀이
# 처음 문제를 접근하는 방법은 쉬웠으나
# 3가지 방법을 어떻게 해야하나 생각해봤으나 떠오르지 않았다.
# 찾아보니 3중으로 만들어서 처리하는 방법을 알게됨.

import sys

N = int(sys.stdin.readline())
arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
# [y][x][0,1,2] 0:가로 1:세로 2:대각선
dp = [[[0]*3 for _ in range(N)] for _ in range(N)]

dp[0][1][0] = 1 

# 첫 dp를 채우기 위해 가로로 쭉 갔을경우 채움
for i in range(2, N) :
    if arr[0][i] == 0 :
        dp[0][i][0] = dp[0][i-1][0]

# 이동시작 
for y in range(N) :
    for x in range(2,N) :
        if arr[y][x] == arr[y][x-1] == arr[y-1][x] == 0 : # 대각선은 3곳이 0이어야함
            dp[y][x][2] = dp[y-1][x-1][0] + dp[y-1][x-1][1] + dp[y-1][x-1][2] # 3가지 방법을 다 더해줘야함

        if arr[y][x] == 0 :
            dp[y][x][0] = dp[y][x-1][2] + dp[y][x-1][0] # 대각선과 가로
            dp[y][x][1] = dp[y-1][x][2] + dp[y-1][x][1] # 대각선과 세로

print(sum(dp[-1][-1]))




