# https://www.acmicpc.net/problem/11048

# 문제해석
# 오른쪽 아래 오른쪽 대각선으로 밖에 이동불가능
# 최대합을 구하라

# 입력
# 첫째 줄에 미로의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 1,000)

# 둘째 줄부터 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다.

# 출력
# 첫째 줄에 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수를 출력한다.

# 예제 입력 1 
# 3 4
# 1 2 3 4
# 0 0 0 5
# 9 8 7 6
# 예제 출력 1 
# 31
# 예제 입력 2 
# 3 3
# 1 0 0
# 0 1 0
# 0 0 1
# 예제 출력 2 
# 3
# 예제 입력 3 
# 4 3
# 1 2 3
# 6 5 4
# 7 8 9
# 12 11 10
# 예제 출력 3 
# 47

# 문제풀이
# 옛날에 파이썬 첨할때 이런 비슷한 문제를 풀었던 경험이 있어서 접근 방법은 바로 알 수 있었고
# 다만 dp 문제로밖에 풀 수 없는 문제이다.
# 경우의 수를 주고 최대값을 더해나가는 것이다!


import sys

N, M = map(int, sys.stdin.readline().split())
miro = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] # 숫자를 받기
dp = [[0]*(M+1) for _ in range(N+1)] #dp값은 0으로 가득 채운다

for y in range(1,N+1) :
    for x in range(1,M+1) :
        dp[y][x] = miro[y-1][x-1] + max(dp[y-1][x-1], dp[y][x-1], dp[y-1][x])
                #받은 값중 해당하는 값을 더해주고 + 왼쪽 + 왼쪽 대각선위 + 위 중 최대값을 받는다

print(dp[-1][-1]) # 마지막에 오른쪽 끝으로 이동하기 때문에 마지막 값을 출력
